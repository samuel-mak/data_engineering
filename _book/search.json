[
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "The basic data engineering shits to know as analysts in an organisation",
    "section": "",
    "text": "Computer programme\n\nConcept\n\nA set of computerised instructions (e.g. codes) executed by a computer(s) to perform specific tasks\n\n\nSoftware\n\nConcept\n\nA package of computer programmes, data, and documents for computers to perform a set of specific and usually related tasks and manage the package (e.g. organising, updating, memory management)\n\n\nApplication\n\nConcept\n\nUsually refers to the front-end of a usually lighter-weight software\n\n\nServer\n\nConcept\n\nA computer programme that serves a client or clients in a network by receiving and responding to service request from individual clients\nThere are different types of servers, e.g. web server, database server, file server, gaming server, application server\n\n\nClient - A client is something that sends requests to a server\nEngine\n\nConcept\n\nThe core component of something that serves as the foundation of the thing (e.g. performs the fundamental functionality of that thing)\n\n\nData engineering\n\nConcept\n\nAny activities relating to the development (design and implementation) and maintenance of systems and processes for managing data (e.g. scripts/automation pipelines for procedures, legality, documentation, handling procedures), which generally involves the acquisition of raw data from various data sources, the production of more usable data from these raw data for targeted downstream users or uses at various levels (e.g. statisticians/data scientists, data analyst, customers, management), and storing these data.\n\n\nData\n\nConcept\n\nComputerised information\nInformation that is essentially transformed into a series of 1s and 0s to represent that information\n\n\nDatabase\n\nConcept\n\nA collection of data that are usually related in some way (e.g. meaning/process/data flow/purpose)\n\n\nData store\n\nConcept\n\nA repository for storing/organising and/or managing data\nIt can be as simple as a file system (e.g. text files, csv files, JSON files) or as complex as a DBMS\n\n\nDatabase server\n\nConcept\n\nA server of a DBMS\nA server that serves clients with regards to a DBMS\nE.g. MS SQL Server is a database server of the MS SQL DBMS, end-users might communicate with the server through its GUI called MS SQL Server Management Studio\n\n\nDatabase management system (DBMS)\n\nConcept\n\nA system for managing data (e.g. storage, organisation, optimisation)\nE.g. Microsoft SQL Server, Microsoft Access, Oracle, MySQL, PostgreSQL, MariaDB, SQLite\nA DBMS involves a database engine for storing and managing data and may involve a database server, a GUI for end-users to interact with the engine, and other service and tools (depending on the DBMS and edition/version)\n\n\nDatabase system\n\nConcept\n\nA database system refers to the combination of data, the DBMS that manages them, and any hardware hosting them\n\n\nData lake/warehouse/mart\n\nIntroduction\n\nThis is a data management system that cut all available data into subsets in order to support business needs\n\nData lake\n\nA database that stores data that are not necessarily ready to be used by downstream users (usually described as raw and unstructured)\n\nData warehouse\n\nA database that stores data that are ready to be used by all downstream users (usually described as relatively structured, clean, concise, accessible/intuitive compared to those in data lake)\nThis is where different teams/units/groups/departments within an organisation can potentially access other teams’ data marts (supporting cross-team collaborations)\n\nData mart\n\nA subset of data warehouse that is targeted for specific downstream users (e.g. a department/team or unit within a department)\n\n\nExtract, transform, load (ETL)\n\nConcept\n\nA process that first involve selecting (the “extract” in ETL) key data from multiple sources (e.g. databases, files, applications, other data repositories), modifying (the “transform” in ETL) these selected data according to downstream users (e.g. cleaning, tidying, deriving higher-order data, aggregating, changing the representation/organisation of the information), and finally transferring (the “load” in ETL) the output to specific databases or data warehouse/mart\nETL typically refers to the process for the output that would be transferred to the data warehouse/mart\nThis concept is meaningful in the context of automated pipeline for data flow\n\n\nOpen Database Connectivity (ODBC)\n\nConcept\n\nAn ODBC is a connection between an software/application (e.g. R, Python, SPSS, Excel) and a DBMS\n\n\nODBC interface\n\nConcept\n\nAn API that manages one or more ODBCs\nProvides a standard and general set of calls/commands (via ODBC functions) for softwares/applications to ODBC compliant DBMS (e.g. executing an SQL script), this standarisation and generalisation enables an ODBC to be independent of applications\nDeveloped by Microsoft in early 1990s\n\n\nODBC driver\n\nConcept\n\nAn ODBC driver provides a connection between an ODBC interface and a DBMS\nAn ODBC interface connects to different ODBC drivers as different DBMSs operate differently thus have their own specific DBMS function calls\nAn ODBC driver translates ODBC function calls into DBMS-specific function calls and passes them to the specific DBMS\nThis enables an ODBC interface to be independent of DBMSs\nE.g. The old SQL Server and the new ODBC for SQL Server (these are drivers, despite having the word “servers” in their names)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Engineering",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "r.html",
    "href": "r.html",
    "title": "R",
    "section": "",
    "text": "Things to add\ninstall.packages(“installr”) installr::updater()\nThis downloads the installer (.exe file) from CRAN (https://cran.r-project.org/bin/windows/base/) and run it. You will go through several installation setup wizards, including one for specifying whether you want to migrate all your packages from your old R to your new. All of these can be done manually, but the updater() function does all of them automatically. Might worth noting that updating R using the installr package only works for Windows, for MacOS, use the updateR package\nAfter all those installation wizards, make sure RStudio is using the latest R version, otherwise change that. To do that, go to the “Tools” tab (in the top-most bar), then go to “Global Options”, this opens an Options dialog box. In the dialog box, go to “General” and then “Basic”. Make sure the “R version” is set to the path to the new R, which may look something like “C:.0”. If not then change it by clicking “change”, which opens another dialog box, and select the appropriate one under “Choose a specific version of R”. Then restart RStudio.\n22 Oct 2022 at 9:46"
  },
  {
    "objectID": "r.html#s3",
    "href": "r.html#s3",
    "title": "R",
    "section": "S3",
    "text": "S3\n\nIntroduction\n\nAn OOP system developed by John Chambers, Rick Becker and colleagues at Bell Labs in the early 1990s for the S programming language and implemented for the R programming language\nIt is named “S3” it was developed for version 3 of the S programming language\nThe simplest OOP system that an OOP could possibly be ## S4\n\n\nIntroduction\n\nAn OOP system developed by John Chambers and members of the R Core Team in the mid-1990s for the S programming language and is implemented in the R programming language\nIt was developed and introduced as a more formal, rigorous, and complex OOP system than S3\nIt is named “S4” because it was developed for version 4 of the S programming language\nFeatures of S4:\n\nMethods belong to functions\nFollows a more functional programming style\nMore formal and rigorous than S3\nClasses have formal definitions for their fields and inheritance (thus more formal and rigorous than S3)\nMultiple dispatch (thus more complicated than S3)\nMultiple inheritance (thus more complicated than S3)\n\nExample\n\nAn example case is used to demonstrate the fundamentals of the S4 OOP system. In this example, the analytical flow of three data-learning models, specifically, the specification, fitting, and accessing parameters of the General Linear Model, the Generalised Linear Model, and the Neural Network Model, are implemented using the S4 OOP system.\nNote that the relationship between the General Linear Model and the Generalised Linear Model can be viewed differently, depending on specific goals (e.g. pedagogy, implementation). It can be viewed that the Generalised Linear Model is a general class of models that includes the General Linear Model as a special case where the identity function is the link, this tends to be viewed in the field of statistics. It can also be viewed that the General Linear Model is a general class which includes the Generalised Linear Model as an extension by adding the link function, this view is more in line with the concept of classes in object-oriented programming. While both views are valid, the latter view is adapted to demonstrate the inheritance of classes in the S4 OOP system.\n\n\nClasses\n\nIntroduction\n\nS4 classes have a more formal definition than S3 classes\nAn S4 class is defined by the name of the class, a set of parameters and their data types\nThe set of parameters is referred to as the “representation” and individual parameters are referred to as “slots” or “representations” (conceptualised as similar to the concept of “attributes” in S3 classes)\n\nClass creation\n\nThe setClass function creates an S4 class with its definition specified through its arguments and returns an object generator function of the class (hereinafter referred to as “generator function”).\nThe generator function provides one of two ways of creating objects of the class (more details in the objects section). More relevant here is that purely calling setClass would only return the generator function (and create the class) but not registering the returned generator function as an object in the variable environment that could be used. The output of setClass needs to be assigned to an object, ideally with its name the same as the class name for clarity, for the generator function to be used. As mentioned, the generator function is only one of two ways of creating objects of the class, hence, creating a class by simply calling setClass without assigning the output to an object is sufficient, but additionally assigning the output to an object is recommended as this eliminates any ambiguity if two classes from different packages have the same name with relative ease.\nThe setClass function has the general usage\n\nclass_name &lt;- setClass(Class = \"class_name\", representation, prototype, contains)\n\nWhere\n\nThe Class argument specifies the name of the class\nThe representation argument specifies the representation and the data types of the slots\nThe prototype argument specifies the default values of the slots, these must conform to their specified data types\nThe contains argument specifies any subclasses of the class from which slots are inherited\n\n\n\n\n\nExample\n\n\n# Create some data\nattainment_data &lt;- data.frame(\n  ks1_maths = rnorm(100, mean = 0, sd = 15),\n  ks2_maths = rnorm(100, mean = 0, sd = 15),\n  ks2_science = rnorm(100, mean = 0, sd = 15),\n  ks2_english = rnorm(100, mean = 0, sd = 15),\n  ks2_art = rnorm(100, mean = 0, sd = 15),\n  school_teaching_quality = rnorm(100, mean = 0, sd = 15),\n  idaci = abs(rnorm(100, mean = 0, sd = 15)),\n  ses = rpois(n = 100, lambda = 5),\n  home_to_school_travel_time = rpois(n = 100, lambda = 50),\n  diet_quality = rpois(n = 100, lambda = 10)\n)\n\n# Create a class \"general_linear_model\" that's defined by two slots of \"y\", an outcome as a character string/vector with no default values, and \"x\", the predictors as a character string/vector with an NA character as the default value \nsetClass(\n  Class = \"general_linear_model\",\n  representation = representation(\n    y = \"character\", # The outcome\n    x = \"character\" # The predictor(s)\n  ),\n  prototype = prototype(\n    x = NA_character_ # Setting an NA character as the default for \"x\"\n    )\n  )\n\n# Create a class \"generalised_linear_model\" defined by (slots in) its superclass \"general_linear_model\" while extending it by adding a slot \"family\" for the link function. Assign the output (the returning generator function) to an object \"generalised_linear_model\", so that this object can be used as its generator function.\ngeneralised_linear_model &lt;- setClass(\n  Class = \"generalised_linear_model\",\n  representation = representation(\n    family = \"function\" # The link function\n    ),\n  prototype = prototype(\n    family = identity  # Setting the identity function as the default link function \n    ),\n  contains = \"general_linear_model\" # Specifying that the \"generalised_linear_model\" class is a subclass/childclass/extension/special case of the superclass/parentclass \"general_linear_model\" (it contains all the slots of the \"general_linear_model\" class). This effectively inherits all class definitions of the class \"general_linear_model\" (i.e. \"x\" and \"y\"). Hence, this class has a total of three slots.\n  )\n\n\n\n# Create a class \"neural_network_model\" defined by slots of \"x\", the predictors, and \"y\", the outcomes\nneural_network_model &lt;- setClass(\n  Class = \"neural_network_model\",\n  representation = representation(\n    y = \"character\",\n    x = \"character\"\n    )\n  )\n\n# Access basic properties of the class \"generalised_linear_model\"\nshowClass(\"generalised_linear_model\")\n\n# Access whether \"generalised_linear_model\" is an extension of \"general_linear_model\"\nextends(class1 = \"generalised_linear_model\", class2 = \"general_linear_model\")\n\n# Removing the class \"general_linear_model\"\n# removeClass(\"general_linear_model\")\n# Removing a parent class does not remove its children, though, the inheritance structure would be lost and the children wouldn't be children \n\nInstances\n\nIntroduction\n\nInstances are objects (instance object) representing cases of a class that take on specific slot values\nInstances of a subclass are also instances of its superclasses, however, instances of a superclass are not instances of their subclasses. This affects methods dispatch.\n\ninstance creation\n\nS4 instances are created by the new function with its class and values of slots specified through its arguments\nThe new function has the general form\n\nnew(Class, ...)\n\nWhere\n\nThe Class argument specifies the name of the class the instance is of\n... is the set of slots of the specified class as arguments that specify values of the slots for the instance\n\n\n\nS4 instances of a class can also be created indirectly by its generator function with its values of slots specified through its arguments (applicable only if the generator function exists as a function object), calling the generator function would in turn call the new function to create the instance\nThe generator function has similar form as the new function (only difference is that it doesn’t have the Class argument because it has been specified)\n\ngenerator_function(...)\n\nWhere\n\ngenerator_function is the name of the generator function\n... is the set of slots of the specified class as arguments that specify values of the slots for the instance\n\n\n\n\nAccess and modify values of slots of instances\n\nValues of slots of instances can be assessed using two methods, either through the @ symbol (instance@slot_name) or the slot function (slot(object  = instance, name = \"slot_name\"))\nAssessed values can then be modified using the assignment operator &lt;- (i.e. instance@slot_name &lt;- value or slot(instance, \"slot_name\") &lt;- value)\n\nExample\n\n\n# Create an instance of class \"general_linear_model\" using the new function with the value of \"y\" being \"ks2\" and values of \"x\" being \"ks1_maths\" and \"school_teaching_quality\"\nmaths_general_linear_model &lt;- new(\n  Class = \"general_linear_model\",\n  y = \"ks2_maths\",\n  x = c(\"ks1_maths\", \"school_teaching_quality\")\n)\n \n# Access properties of the instance \"maths_general_linear_model\"\nstr(maths_general_linear_model)\n\n# Access whether the object \"maths_general_linear_model\" is an object of an S4 class\nisS4(maths_general_linear_model)\n\n# Create an instance of class \"generalised_linear_model\" using its generator function (as the generator function exists in the form of an object in the environment)\nmaths_generalised_linear_model &lt;- generalised_linear_model(\n  y = \"ks2_maths\",\n  x = c(\"ks1_maths\", \"school_teaching_quality\")\n)\n\n# Create a second instance of class \"generalised_linear_model\" using its generator function\nses_generalised_linear_model &lt;- generalised_linear_model(\n  y = \"ses\",\n  x = \"home_to_school_travel_time\",\n  family = function()identity\n)\n\n# Create an instance of class \"neural_network_nodel\" using its generator function\nscience_neural_network_model &lt;- neural_network_model(\n  y = \"ks2_science\",\n  x = c(\"ses\", \"idaci\", \"home_to_school_travel_time\", \"diet_quality\")\n)\n\n# Access the value of slot \"y\" in the instance \"maths_generalised_linear_model\" using the \"@\" operator\nmaths_generalised_linear_model@y\n\n# Access the value of a specific slot \"x\" in the instance \"maths_generalised_linear_model\" using the `slot` function\nslot(maths_generalised_linear_model, \"x\")\n\n# Modify the value of the slot \"family\" in the instance \"ses_generalised_linear_model\" using the \"@\" operator\nses_generalised_linear_model@family &lt;- function()poisson(link = \"log\")\n\n# Modify the value of the slot \"x\" in the instance \"maths_generalised_linear_model\" using the `slot` function\nslot(maths_generalised_linear_model, \"x\") &lt;- c(\"ks1_maths\", \"school_teaching_quality\", \"idaci\")\n\nGeneric functions (Generics), Methods, and Methods Dispatch\n\nIntroduction\n\nGenerics and methods\n\nA generic is a function that can take different input (in terms of the class of the inputs to the arguments and/or the set of arguments) and operate and/or behave in different specific ways according to the input upon being called\nThis is done by the generic having a set of associated methods, which are functions that implement for specific cases in terms of the inputs to the arguments to the generic, and having the generic dispatch to one of its methods upon being called through a process called methods dispatch, which involves matching and identifying the most appropriate method and passing the inputs to the arguments to the generic to that method\n\nInheritance\n\nSince instances of a subclass are also instances of its superclasses, methods defined for instances of a superclass are also applicable to instances of its subclasses. However, since instances of a superclass are not instances of their subclasses, methods defined for instances of a subclass are not applicable to instances of its superclasses\n\n\nCreating a generic\n\nThe setGeneric function creates or coerces an existing function as an S4 generic\nThe setGeneric function has the general form:\n\nsetGeneric(name, def)\n\nWhere\n\nname is the name of the generic\ndef is the “skeleton” of the generic or the non-generic (default) method of the generic as a function. This function should also include the standardGeneric function (specifically standardGeneric(f = \"generic_name\")) for initiating the S4 methods dispatch mechanism. (All of these are needed only when creating a generic)\n\n\n\n\nCreating a method\n\nThe setMethod function creates a method for a generic\nThe setMethod function has the general form\n\nsetMethod(f, definition)\n\nWhere\n\nf is the name of the generic\nsignature is the case of the classes of the inputs to the arguments to the generic for the method specified through the signature function\ndefinition is the method for the generic as a function\n\n\n\n\nTips\n\nAll signatures of a generic can be assessed by the showMethod function (showMethod(f = generic))\nAll generics and their signatures of a class can be assessed by the showMethods function (showMethods(classes = \"classname\")\n\nMethods Dispatch\n\nMethods dispatch is the process in which the most appropriate method of a generic is selected to be executed with the inputs to the generic upon being called based on R’s selection criteria/algorithm\n\n\nThe process in detail\n\n\nThe generic is called with specified inputs to its arguments\nThe classes of the input to the arguments to the generic are identified\nMethods matching and selection\nThe inputs to the generic are compared with the defined inputs to each of the methods in their signatures\nThe set of specified arguments in the generic being called is compared to the set of arguments to each of the methods\nIf none of the methods has the same set of arguments in their signatures as the arguments that’s being specified in the generic called, an error is returned to with a message informing that there are unused arguments\nIf there exists some methods with the same set of arguments in their signatures as the arguments that’s being specified in the generic called, if there is only one method, the method is selected and executed, if there are multiple methods, then those methods are selected for further matching and selection\nThe classes of the inputs to the arguments to the generic called are compared with the defined classes of the inputs to the arguments to each of the methods in their signatures\nIf the class of the input to at least one argument to the generic called is different to and is not a subclass of the class defined for the corresponding argument to all the methods, then an error is returned with a message informing that no methods exist for inputs of that class\nIf the class of the input to all the arguments to the generic called is exactly the same as or a subclass of the defined class of the inputs to corresponding arguments to some methods in their signatures, if there is only one method, then the method is selected and executed, if there are multiple methods, then those methods are selected for further matching and selection\nThe classes of the inputs to the arguments to the generic called are compared to the defined classes of the inputs to the arguments to each of the methods in their signatures in terms of their closeness in class membership/the inheritance hierarchy. Due to previous selections, classes of the inputs to the arguments to the generic called are either exactly the same or subclasses of the classes of the inputs to the corresponding arguments to the methods, hence, closeness refers to whether the classes are exactly the same or, if not, how many generations the classes in the generic are from the classes in the methods.\nA distance is calculated to represent the closeness between the set of classes in the generic called and the set of classes a method (generic-method pair)\nFor each generic-method pair, for each arguments, if the class of the input to the method is the same as that to the generic, then a distance of 0 is given, if the class of the input to the method is a parent to the class of the input to the generic, a distance is 1 is given, if the class of the input to the method is a grandparent to the class of the input to the generic, a distance of 2 is given, and so on. This is calculated for all arguments. Then the distances are summed over the arguments for that generic-method pair to give the total distance for the generic-method pair. This is done to all generic-method pairs. All generic-method pairs are compared in terms of their distances. The method with the smallest distance is selected and executed, however, if there are multiple methods with the smallest distance (i.e. ties), then they are selected for further selection\nIt is recommended not to design generics that go beyond this level of ambiguity, hence, further selections are not covered in detail, but basically, it selects based on the order of the arguments and then the order of the definition of the methods (methods defined earlier are given higher priority)\n\n\n\nExample\n\n\n# Create a generic \"model_description\" that takes one or two models and summarises/compares them\nsetGeneric(\n  name = \"model_description\",\n  def = function(model_1 = NULL, model_2 = NULL){ # The generic is defined to have two generic arguments \"model_1\" and \"model_2\" for specifying the models to be described/compared\n    standardGeneric(f = \"model_description\") # This is for initiating the S4 methods dispatch mechanism \n  },\n  valueClass = \"character\" # Defines the output to be of class character\n)\n\n# Create a generic \"fit\" that would take a model specification and data and fit the specified model to the data \nsetGeneric(\n  name = \"fit\",\n  def = function(model = NULL, data){\n    standardGeneric(f = \"fit\")\n  }\n)\n\n# Coerce the summary function (an existing function) as an S4 generic\n# The goal of this is to use this generic summary to summarise the models fitted by the fit generic by adding specific S4 methods to it later \nsetGeneric(name = \"summary\")\n\n\n\n# Create a method for the generic \"model_description\" for the case when the input to both arguments are of the class \"general_linear_model\"\nsetMethod(\n  f = \"model_description\",\n  signature = signature(model_1 = \"general_linear_model\", model_2 = \"general_linear_model\"),\n  definition = function(model_1, model_2){\n    if(model_1@y == model_2@y){\n      if(identical(unlist(model_1@x), unlist(model_2@x))){\n        paste0(\"Both models are General Linear Models and have the same outcome and predictors\")\n      }else{\n          paste0(\"Both models are General Linear Models and have the same outcome and but different predictors\")\n      }\n    }else{\n      if(identical(unlist(model_1@x), unlist(model_2@x))){\n        paste0(\"Both models are General Linear Models and but have a different outcome and same predictors\")\n      }else{\n          paste0(\"Both models are General Linear Models and have different outcome and predictors \")\n      }\n    }\n  }\n)\n\n# Create a second method for the generic \"model_description\" for the case when the input to both arguments are of the class \"generalised_linear_model\"\nsetMethod(\n  f = \"model_description\",\n  signature = signature(model_1 = \"generalised_linear_model\", model_2 = \"generalised_linear_model\"),\n  definition = function(model_1, model_2){\n    if(model_1@y == model_2@y){\n      if(identical(unlist(model_1@x), unlist(model_2@x))){\n        if(model_1@family()$family == model_2@family()$family){\n          paste0(\"Both models are Generalised Linear Models and have the same outcome, predictors, and family\")\n        }else{\n          paste0(\"Both models are Generalised Linear Models and have the same outcome and predictors but different families\")\n        }\n        \n      }else{\n        if(model_1@family()$family == model_2@family()$family){\n          paste0(\"Both models are Generalised Linear Models and have the same outcome and family but different predictors\")\n        }else{\n          paste0(\"Both models are Generalised Linear Models and have the same outcome but different predictors and families\")\n        }\n      }\n    }else{\n      if(identical(unlist(model_1@x), unlist(model_2@x))){\n        if(model_1@family()$family == model_2@family()$family){\n          paste0(\"Both models are Generalised Linear Models and have same predictors and family but a different outcome\")\n        }else{\n          paste0(\"Both models are Generalised Linear Models and have same predictors but a different outcome and families\")\n        }\n        paste0(\"Both models are Generalised Linear Models and have same predictors but a different outcome \")\n      }else{\n        if(model_1@family()$family == model_2@family()$family){\n          paste0(\"Both models are Generalised Linear Models and the same family but different outcome and predictors\")\n        }else{\n          paste0(\"Both models are Generalised Linear Models but have different outcome, predictors and families\")\n        }\n      }\n    }\n  }\n)\n\n\n\n# Access all signatures of the generic \"model_description\"\nshowMethods(f = model_description)\n\n# Access all generics and their signatures of objects of the class \"general_linear_model\"\nshowMethods(class = \"general_linear_model\")\n\n\n# Create a method for the fit generic for the case when the input to the model argument is of the class \"general_linear_model\"\n# Define the output of this method to be of an S4 class \"general_linear_model_fit\". To do that, the class \"general_linear_model_fit\" and its generator function need to be created first before defining the method as the generator function would be used within the method to define the class of the output of the method \ngeneral_linear_model_fit &lt;- setClass(\"general_linear_model_fit\", representation = representation(call = \"character\", coefficients = \"ANY\"))\nsetMethod(\n  f = \"fit\",\n  signature = signature(model = \"general_linear_model\"),\n  definition = function(model, data){\n    formula &lt;- paste0(model@y, \" ~ \" ,paste0(unlist(model@x), collapse = \" + \"))\n    general_linear_model_fit_object &lt;- lm(formula = formula, data = data)\n    general_linear_model_fit_call &lt;- paste0(as.character(general_linear_model_fit_object$call[1]), \"(\", as.character(general_linear_model_fit_object$call[2]), \", \",as.character(general_linear_model_fit_object$call[3]), \")\")\n    return(general_linear_model_fit(call = general_linear_model_fit_call, coefficients = general_linear_model_fit_object$coefficients))\n  }\n)\n\n# Create a second method for the fit generic for the case when the input to the model argument is of the class \"generalised_linear_model\"\n# Define the output of this method to be of an S4 class \"generalised_linear_model_fit\". Similarly, this class and its generator function are created first before defining the method. In addition, \"generalised_linear_model_fit\" is defined to be a children of \"general_linear_model_fit\", this is used to demonstrate that methods defined for instance objects of a class would also be applicable to instance objects of its subclass (but not the other way round).\ngeneralised_linear_model_fit &lt;- setClass(\"generalised_linear_model_fit\", contains = \"general_linear_model_fit\")\nsetMethod(\n  f = \"fit\",\n  signature = signature(model = \"generalised_linear_model\"),\n  definition = function(model, data){\n    formula &lt;- paste0(model@y, \" ~ \" ,paste0(unlist(model@x), collapse = \" + \"))\n      \n    generalised_linear_model_fit_object &lt;- glm(formula = formula, data = data, family = model@family()$family)\n    generalised_linear_model_fit_call &lt;- paste0(as.character(generalised_linear_model_fit_object$call[1]), \"(\", as.character(generalised_linear_model_fit_object$call[2]), \", \",as.character(generalised_linear_model_fit_object$call[3]), \", \",as.character(generalised_linear_model_fit_object$call[4]), \")\")\n    return(generalised_linear_model_fit(call = generalised_linear_model_fit_call, coefficients = generalised_linear_model_fit_object$coefficients))\n  }\n)\n\n\n# Create a third method for the fit generic for the case when the input to the model argument is of the class \"neural_network_model\"\n# The class of the output of this method is defined to be \"nn\" by the neuralnet::neuralnet function\nsetMethod(\n  f = \"fit\",\n  signature = signature(model = \"neural_network_model\"),\n  definition = function(model, data){\n    formula &lt;- paste0(model@y, \" ~ \" ,paste0(unlist(model@x), collapse = \" + \"))\n      \n    neural_network_model_fit_object &lt;- neuralnet::neuralnet(formula = formula, data = data, linear.output = F)\n    return(neural_network_model_fit_object)\n  }\n)\n\n\n# Create a same method for the summary generic for the case when the input to the object argument is either an instance of the class \"general_linear_model_fit\" or \"generalised_linear_model_fit\"\n# Since the class \"general_linear_model_fit\" is a superclass of its subclass \"generalised_linear_model_fit\", as defined in the inheritance structure when creating the class \"generalised_linear_model_fit\", any methods defined for instances of the class \"general_linear_model_fit\" would also be applicable to instances of the class \"generalised_linear_model_fit\".\n# This means that to create a method for objects of both the parent and child classes \"general_linear_model_fit\" or \"generalised_linear_model_fit\", the method only needs to be defined for the parent class \"general_linear_model_fit\"\nsetMethod(\n  f = \"summary\",\n  signature = signature(object = \"general_linear_model_fit\"),\n  definition = function(object, show_beta = F){\n    print(object@call)\n    if(show_beta){\n    object@coefficients}\n    \n  }\n)\n\n# Create a second method for the summary generic for the case when the input to the object argument is an instance of the class \"neural_network_model_fit\" in a way that the arguments to the summary generic would change accordingly, specifically, the \"show_beta\" argument would be removed and a new argument would be added, further, the \"plot_model\" argument can take inputs of different classes causing the summary function to operate differently by nesting another generic, specifically called \"summary_2\" in the method. Accordingly, the \"summary\" and \"summary_2\" generics may be referred to as the main/external and internal generics. This is to show how a generic can have different sets of arguments depending on the class of the inputs to one or more generic arguments and those new arguments can take inputs of different classes and operate differently according to them. This complex scenario is rare though.\n\n# Create the internal generic \"summary_2\" that would be nested within the methods of the main generic \"summary\" later \nsetGeneric(\n  \"summary_2\", \n  def = function(object, plot_model){\n    standardGeneric(f = \"summary_2\")\n    }\n  )\n\n# Create a method for the internal generic \"summary_2\" for the case when the input to the argument \"plot_model\" is of the class \"logical\" \nsetMethod(\n  f = \"summary_2\", \n  signature = signature(plot_model = \"logical\"),\n  definition = function(object, plot_model){\n            print(\"Input of the plot_model argument is logical\")\n            #print(object$call)\n            if(plot_model){plot(object)}\n          })\n\n# Create a second method for the internal generic \"summary_2\" for the case when the input to the argument \"plot_model\" is of the class \"numeric\"\nsetMethod(\n  f = \"summary_2\", \n  signature = signature(plot_model = \"numeric\"),\n  definition = function(object, plot_model){\n            print(\"Input of the plot_model argument is an numeric\")\n            print(object$call)\n            if(plot_model == 1){plot(object)}\n    }\n  )\n# Create a method for the main generic \"summary\" for the case when input to the \"object\" argument is of the class \"nn\" (the neural network model fit)\nsetMethod(\n  f = \"summary\",\n  signature = signature(object = \"nn\"),\n  definition = function(object, plot_model){summary_2(object = object, plot_model = plot_model)}\n)\n\n\n# Show how it all works in practice\n# Fit the models to the data using the fit generic\n# The fit generic can take various model specifications of various types of model and fit to the same data accordingly \n# Fitting a General Linear Model\nmaths_general_linear_model_fit &lt;- fit(model = maths_general_linear_model, data = attainment_data)\n# Fitting a Generalised Linear Model \nses_generalised_linear_model_fit &lt;- fit(model = ses_generalised_linear_model, data = attainment_data)\n# Fitting a Neural Network Model\nscience_neural_network_model_fit &lt;- fit(model = science_neural_network_model, data = attainment_data)\n\n# Access the model properties using the summary generic \n# The summary generic can take inputs of different classes and change its arguments and operations/output\nsummary(maths_general_linear_model_fit, show_beta = T)\nsummary(ses_generalised_linear_model_fit, show_beta = F)\nsummary(science_neural_network_model_fit, plot_model = T)\nsummary(science_neural_network_model_fit, plot_model = 1)"
  },
  {
    "objectID": "r.html#s4",
    "href": "r.html#s4",
    "title": "R",
    "section": "S4",
    "text": "S4\nIntroduction\n\nAn OOP system developed by John Chambers and members of the R Core Team in the mid-1990s for the S programming language and is implemented in the R programming language\nIt was developed and introduced as a more formal, rigorous, and complex OOP system than S3\nFeatures of S4:\n\nMethods belong to functions\nFollows a more functional programming style\nMore formal and rigorous than S3\nClasses have formal definitions for their fields and inheritance (thus more formal and rigorous than S3)\nMultiple dispatch (thus more complicated than S3)\nMultiple inheritance (thus more complicated than S3)\n\n\nClasses\n\nIntroduction\n\nS4 classes have a more formal definition than S3 classes\nAn S4 class is defined by the name of the class, a set of parameters and their data types\nThe set of parameters is referred to as the “representation” and individual parameters are referred to as “slots” or “representations” (conceptualised as similar to the concept of “attributes” in S3 classes)\n\nClass creation\n\nThe setClass function creates an S4 class with its definition specified through its arguments and returns an object generator function of the class (hereinafter referred to as “generator function”).\nThe generator function provides one of two ways of creating objects of the class (more details in the objects section). More relevant here is that purely calling setClass would only return the generator function (and create the class) but not registering the returned generator function as an object in the variable environment that could be used. The output of setClass needs to be assigned to an object, ideally with its name the same as the class name for clarity, for the generator function to be used. As mentioned, the generator function is only one of two ways of creating objects of the class, hence, creating a class by simply calling setClass without assigning the output to an object is sufficient, but additionally assigning the output to an object is recommended as this eliminates any ambiguity if two classes from different packages have the same name with relative ease.\nThe setClass function has the general usage\n\nclass_name &lt;- setClass(Class = \"class_name\", representation, prototype, contains)\n\nWhere\n\nThe Class argument specifies the name of the class\nThe representation argument specifies the representation and the data types of the slots\nThe prototype argument specifies the default values of the slots, these must conform to their specified data types\nThe contains argument specifies any subclasses of the class from which slots are inherited\n\n\n\n\n\nExample\n\n\n# Create a class \"general_linear_model\" that's defined by two slots of \"y\", an outcome as a character string with no default values, and \"x\", the predictors as a list of character strings with an empty list as the default value.\n\nsetClass(\n  Class = \"general_linear_model\",\n  representation = representation(\n    y = \"character\", # The outcome (univariate only)\n    x = \"list\" # The predictor(s)\n  ),\n  prototype = prototype(\n    x = list() # Setting the default value for the \"x\" parameter as an empty list\n  )\n)\n\n# Create a class \"generalised_linear_model\" defined by the subclass \"general_linear_model\" and an additional slot \"family\", a function for specifying the link function and the exponential sampling distribution of the outcome. Assign the returning generator function to an object called \"generalised_linear_model\".\n\ngeneralised_linear_model &lt;- setClass(\n  Class = \"generalised_linear_model\",\n  representation = representation(\n    family = \"function\" # The exponential sampling distribution of the outcome and the link function\n  ),\n  prototype = prototype(\n    family = identity  # Setting the identity function as the default link function \n  ),\n  contains = \"general_linear_model\" # Specifying that this class, \"generalised_linear_model\", is an extension/superclass of the class \"general_linear\" mode, in other words, the class \"general_linear_model\" is a special case/subclass of this class, \"generalised_linear_model\". This effectively inherits all class definitions of the class \"general_linear_model\" (i.e. \"x\" and \"y\"). Hence, this class has a total of three slots.\n)\n\n# Look at the properties of the class \"generalised_linear_model\"\nshowClass(\"generalised_linear_model\")\n\nObjects\n\nObject creation\n\nS4 objects are created by the new function with its class and values of slots specified through its arguments\nThe new function has the general form\n\nnew(Class, ...)\n\nWhere\n\nThe Class argument specifies the name of the class the object is of\n... is the set of slots of the specified class as arguments that specify values of the slots for the object\n\n\n\nS4 objects of a class can also be created indirectly by the generator function with its values of slots specified through its arguments (applicable only if the generator function was assigned to an object to be used), the generator function would in turn call the new function to create the object\nThe generator function has similar form as the new function (only difference is that it doesn’t have the Class argument)\n\ngenerator_function(...)\n\nWhere\n\n... is the set of slots of the specified class as arguments that specify values of the slots for the object\n\n\n\n\nAccess and modify values of slots of objects\n\nValues of slots of objects can be assessed using two methods, either through the @ symbol or the slot function\nAssessed values can then be modified using the assignment operator &lt;-\nUsing the @ symbol\n\nAccess values of slots of objects\n\nobject@slot_name\n\nModify the assessed values of slots of objects\n\nobject@slot_name &lt;- value\n\n\nUsing the slot function\n\nAccess values of slots of objects\n\nslot(object, \"slot_name\")\n\nModify the assessed values of slots of objects\nslot(object, \"slot_name\") &lt;- value\n\n\nExample\n\n\n# Create an object of class \"general_linear_model\" using the new function\n# Specifically, a model with the outcome of \"ks2_maths\" and predictors of \"ks1_maths\" (prior attainment) and \"school_teaching_quality\"\n\nmaths_general_linear_model &lt;- new(\n  Class = \"general_linear_model\",\n  y = \"ks2_maths\",\n  x = list(\"ks1_maths\", \"school_teaching_quality\")\n)\n \n\n# Look at the properties of the object \"maths_general_linear_model\"\nstr(maths_general_linear_model)\n\n# Look at whether the object \"maths_general_linear_model\" is an S4 object\nisS4(maths_general_linear_model)\n\n\n# Create an object of class \"generalised_linear_model\" using its generator function (as the generator function was assigned to an object)\nmaths_generalised_linear_model &lt;- generalised_linear_model(\n  y = \"ks2_maths\",\n  x = list(\"ks1_maths\", \"school_teaching_quality\")\n)\n\n\n# Access the value of specific slots of an object \n\n# Method 1: Using the @ symbol (similar to the $ symbol in S3 objects)\nmaths_generalised_linear_model@y\n\n# Method 2: Using the slot function\nslot(maths_generalised_linear_model, \"y\")\n\n\n# Specify or re-specify values of slots of an object after object creation\n\n# Method 1: Using the @ symbol (like $ in S3)\nmaths_generalised_linear_model@family &lt;- function(){poisson(link = \"log\")}\n\n# Method 2: Using the slot function\nslot(maths_generalised_linear_model, \"x\") &lt;- list(\"ks1_maths\", \"school_teaching_quality\", \"idaci\")\n\n\n# browseURL(here::here(\"_book/index.html\"))\n\n\nMultiple dispatch - Methods dispatch can be based on multiple arguments to a generic\nMultiple inheritance - A class can inherit properties from multiple parent classes\n\n\n\n\n\nBengtsson, H. (2003). The R.oo package - object-oriented programming with references using standard R code. https://www.r-project.org/conferences/DSC-2003/Proceedings/Bengtsson.pdf\n\n\nChang, W. (2021). R6: Encapsulated classes with reference semantics. https://CRAN.R-project.org/package=R6\n\n\nGrothendieck, G., Kates, L., & Petzoldt, T. (2016). Proto: Prototype object-based programming. https://CRAN.R-project.org/package=proto"
  },
  {
    "objectID": "odbc.html",
    "href": "odbc.html",
    "title": "Working with DBMS",
    "section": "",
    "text": "odbc - Connects R with the database - Helps DBI package to interface with the ODBC driver in ODBC interface\nDBI - An interface Uses S4"
  },
  {
    "objectID": "r_and_dbms.html",
    "href": "r_and_dbms.html",
    "title": "Working with DBMS using R",
    "section": "",
    "text": "Introduction\n\nVarious DBMSs can be worked with using R\nThe specific way that this is done differ between the DBMSs and operating system\n\nWorking with ODBC-compliant DBMS from ODBC-compliant applications\n\nThe General Process\n\nODBC-compliant DBMSs and applications are those that adhere to ODBC standards thus can be connected through ODBC\nODBC-compliant DBMSs include Microsoft SQL Server, Microsoft Access, and MySQL, ODBC-compliant applications include R, Python, Excel, and SPSS\nWorking with an ODBC-compliant DBMS from an ODBC-compliant application necessarily involves, in addition to the application and the DBMS, an ODBC interface, an ODBC manager, and a DBMS-specific ODBC driver, all for mediating the connection between the application and the DBMS.\nUpon a request being called by the application, the application sends the application-specific call to the ODBC interface, the ODBC interface translates the application-specific calls from the application to an ODBC call, which is a call adhering to the ODBC standards, through its ODBC functions, it then establishes a connection with and sends the ODBC call to the DBMS-specific ODBC driver either directly or indirectly through the ODBC manager, which manages one or more DBMS-specific ODBC drivers.\nThe DBMS-specific ODBC driver translates the ODBC call to a DBMS-specific call (which may involve DBMS-specific SQL), it then establishes a connection to and sends the DBMS-specific call to the DBMS (e.g. its server/engine) where the call is executed.\nIf the call involves extracting information from the DBMS, the DBMS sends the information to its DBMS-specific ODBC driver, the DBMS-specific ODBC driver fetches the information from the DBMS, translates it to an ODBC information, and sends it to the ODBC interface, the ODBC interface fetches the ODBC information from the DBMS-specific driver and may further process it (e.g. translation) if there is an upper layer (e.g. application).\n\nGeneral Steps\n\nMake sure an ODBC manager is ready for use\n\nODBC managers are usually an individual software/programme that are specific to an operating system, hence, they should be considered with regards to specific operating systems:\n\nWindows OS\n\nWindows OS comes with an ODBC manager in the form of a system application called “ODBC Data Source Administrator”.\n\nMacOS\n\nMacOs used to come with an ODBC manager in form of system application called “ODBC Administrator” until Mac OS “Snow Leopard” from which ODBC managers for MacOS are downloaded from external developers. ODBC managers for MacOS include:\n\nODBC Manager\n\nODBC Manager is free proprietary ODBC manager developed by Actual Technologies\nGo to  ODBC Manger  to learn more or download\n\nIndependent ODBC (iODBC) for MacOS\n\niODBC is both an open-source initiative initiated and managed by OpenLink Software that encourages the open-source development of ODBC managers for various Linux or Unix-based OS (incl. MacOS) and the ODBC managers under this initiative\nGo to  iODBC  to learn more about iODBC and to download\n\n\n\n\n\nMake sure an ODBC driver for the DBMS is ready for use\n\nODBC-specific ODBC drivers are usually an individual software/programme that is specific to a DBMS, hence, they should be considered with regards to the DBMS:\n\nMicrosoft SQL Server\n\nODBC Driver for SQL Server\n\nDeveloped and distributed by Microsoft\nGo to  ODBC Driver for SQL Server  to learn more or download\n\n\nMySQL\n\nConnector/ODBC\n\nDeveloped and distributed by MySQL\nGo to  MySQL  to download\n\n\n\n\nMake sure an ODBC interface is ready for use\n\nODBC interfaces are usually specific to the application and exist as either an in-built functionality of the application or an extension (e.g. packages/modules/plug-ins), hence, they should be considered with regards to the application:\n\nR\n\nDBI\n\nAn R package in CRAN developed by R Special Interest Group on Databases (R-SIG-DB) and Hadley Wickham and maintained by Kirill Müller\nInstall/update the DBI package from CRAN by running the R command if it hasn’t been installed/needs to be updated\n\n\nInstallation guidance\n\n\nInstall the package DBI by running the following R codes\n\ninstall.package(\"DBI\")\n\nYou can access whether the package DBI is installed in R by running the following R codes\n\n\"DBI\" %in% installed.packages()\n\nThe version of the installed DBI package can be accessed by running the following R codes\n\npackageVersion(\"DBI\")\n\n[1] '1.2.2'\n\n\n\n\n\n\nSee package documentation by running RShowDoc(what = \"DBI\", package = \"DBI\")\n\nRODBC\n\nAn R package developed by Brian Ripley and Michael Lapsley and maintained by Brian Ripley\nInstall/update the RODBC package from CRAN by running the R command if it hasn’t been installed/needs to be updated\n\n\nInstallation guidance\n\n\nInstall the package DBI by running the following R codes\n\ninstall.package(\"DBI\")\n\nIt has been reported that the above method may not work for MacOS (e.g.  here on Stack Overflow )\n\n\nClick here for an alternative method for MacOS\n\n\nAny CRAN packages can be installed in the terminal\nInstall the Homebrew command line utility if it hasn’t been installed by running the following Bash commands in the terminal\n\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\nInstall wget using Homebrew if it hasn’t been installed by running the following brew command line utility codes in the terminal\n\nbrew install wget\n\nDownload the package tar.gz file from CRAN to the Shell directory by running the following wget command line utility codes in the terminal\n\nwget \"http://cran.r-project.org/src/contrib/tar_filename.tar.gz\"\n\nInstall the package to R by running the following R command line utility codes in the terminal\n\nR CMD INSTALL tar_filename.tar.gz\n\nWhere\n\ntar_filename is the name of the tar.gz file of the package on CRAN, which can change, especially with the version of the package. The name of the tar.gz file for the latest version an R package on CRAN can be found on CRAN here\n\n\n\nRemove the initially downloaded tar.gz file by running the following bash commands in the terminal\n\nrm tar_filename.tar.gz\n\nWhere\n\ntar_filename is the name of the tar.gz file of the package initially downloaded from CRAN\n\n\n\n\n\nYou can access whether the package DBI is installed in R by running the following R codes\n\n\"DBI\" %in% installed.packages()\n\nThe version of the installed DBI package can be accessed by running the following R codes\n\npackageVersion(\"DBI\")\n\n\n\nSee package documentation by running RShowDoc(what = \"RODBC\", package = \"RODBC\")\n\nComparison\n\nBoth DBI and RODBC are reliable, simple to use, and developed by great developers. However, DBI has more functionalities (e.g. error handling, integrative functionalities with RStudio, specifically, it usefully shows the structure of the connected DBMS engine/server with databases, tables and table columns and their data types in the “Connection” pane), covers more data sources (i.e. DBMSs), and, in some cases/reportedly seems to be faster than RODBC\n\n\n\n\n\n\n\npackageVersion(\"RODBC\")\n\n[1] '1.3.23'\n\n\n\nWorking with a DBMS from R\n\nConnecting R to Microsoft SQL Server\n\nDBI\n\nThe dbConnect() function connects R to a DBMS-specific ODBC driver/\nThe dbConnect() function has the general form and usage\n\nconnection_object_dbi &lt;- DBI::dbConnect(drv, ...)\n\n\nWhere\n\ndrv is the back-end of dbConnect that drives the connection based on the\n\n\n\nRODBC\n\nconnection_object_rodbc &lt;- RODBC::odbcDriverConnect(\n  connection = \"Driver={ODBC Driver 17 for SQL Server};Server={Server Name};Database={Database Name};\"\n  )\n\n\n\n\nsomethig - Something - Notes - The “Driver” and “Server” parameters are required while the “Database” parameter is optional and can be specified downstream when specifying a request call to the DBMS\n\nsystem(paste(\"open -a 'Google Chrome' \",\"_book/index.html\"))\n\nFor Windows, Windows comes with an ODBC manager, \nThe ODBC interface is usually associated with the application, specifically, it is either a functionality of the application or an extension to the application (e.g. packages/modules/plug-ins). The ODBC-specific ODBC driver is usually a separate software associated with the DBMS The DBMS-specific ODBC driver is usually associated with the DBMS, - Some terms - DBMS - A system for managing data - Examples include Microsoft SQL Server, Microsoft Access, Oracle, MySQL, PostgreSQL, MariaDB, SQLite - Open Database Connectivity (ODBC) - An ODBC is a connection between a software/application (e.g. R, Python, SPSS, Excel) and a DBMS through an ODBC interface/system (a standardised connection) - ODBC-compliant DBMS - ODBC-compliant DBMSs are DBMSs that adheres to the ODBC standards to allow applications to access them through ODBC (a standardised way of doing so) - ODBC-compliant DBMSs include Microsoft SQL Server, Microsoft Access, MySQL, PostgreSQL, Oracle Database, IBM Db2, SQLite, MariaDB, Amazon Redshift, Google BigQuery, etc.\nOpen Database Connectivity (ODBC)\n\nConcept\n\nAn ODBC is a connection between an software/application (e.g. R, Python, SPSS, Excel) and a DBMS\n\n\nODBC interface\n\nConcept\n\nAn API that manages one or more ODBCs\nProvides a standard and general set of calls/commands (via ODBC functions) for softwares/applications to ODBC compliant DBMS (e.g. executing an SQL script), this standarisation and generalisation enables an ODBC to be independent of applications\nDeveloped by Microsoft in early 1990s\n\n\nODBC driver\n\nConcept\n\nAn ODBC driver provides a connection between an ODBC interface and a DBMS\nAn ODBC interface connects to different ODBC drivers as different DBMSs operate differently thus have their own specific DBMS function calls\nAn ODBC driver translates ODBC function calls into DBMS-specific function calls and passes them to the specific DBMS\nThis enables an ODBC interface to be independent of DBMSs\nE.g. The old SQL Server and the new ODBC for SQL Server (these are drivers, despite having the word “servers” in their names)\n\n\nDSN - A parametric data structure/format that contains information for an ODBC driver to connect to a specific part of a DBMS (e.g. server/engine/database/table) - DSNs are ODBC driver-specific, but they tend to be simple and short with common parameters - Parameters of the DSN for an ODBC driver includes the name of the engine, name of the server, name of the database, name of the table, username and password for access\nWindows - In general - - ODBC Interface (API) - ODBC Drivers\n\n\nODBC Data Source Administrator\nODBC Manager\nODBC driver\n\nSet up a connection between the ODBC interface and the database\nODBC driver (install)\nThe ODBC Data Source Administrator (64-bit)\nSet up a connection between R and the ODBC interface\nR"
  },
  {
    "objectID": "s4.html",
    "href": "s4.html",
    "title": "R",
    "section": "",
    "text": "Things to add\ninstall.packages(“installr”) installr::updater()\nThis downloads the installer (.exe file) from CRAN (https://cran.r-project.org/bin/windows/base/) and run it. You will go through several installation setup wizards, including one for specifying whether you want to migrate all your packages from your old R to your new. All of these can be done manually, but the updater() function does all of them automatically. Might worth noting that updating R using the installr package only works for Windows, for MacOS, use the updateR package\nAfter all those installation wizards, make sure RStudio is using the latest R version, otherwise change that. To do that, go to the “Tools” tab (in the top-most bar), then go to “Global Options”, this opens an Options dialog box. In the dialog box, go to “General” and then “Basic”. Make sure the “R version” is set to the path to the new R, which may look something like “C:.0”. If not then change it by clicking “change”, which opens another dialog box, and select the appropriate one under “Choose a specific version of R”. Then restart RStudio.\n22 Oct 2022 at 9:46"
  },
  {
    "objectID": "s4.html#s3",
    "href": "s4.html#s3",
    "title": "R",
    "section": "S3",
    "text": "S3\n\nIntroduction\n\nAn OOP system developed by John Chambers, Rick Becker and colleagues at Bell Labs in the early 1990s for the S programming language and implemented for the R programming language\nIt is named “S3” it was developed for version 3 of the S programming language\nThe simplest OOP system that an OOP could possibly be ## S4\n\n\nIntroduction\n\nAn OOP system developed by John Chambers and members of the R Core Team in the mid-1990s for the S programming language and is implemented in the R programming language\nIt was developed and introduced as a more formal, rigorous, and complex OOP system than S3\nIt is named “S4” because it was developed for version 4 of the S programming language\nBelow gives a brief practical introduction to S4 (there are more to what’s mentioned below)\nR packages using S4 include EBImage by Bioconductor and Matrix by Douglas Bates and Martin Maechler\nFeatures of S4:\n\nMethods belong to functions\nFollows a more functional programming style\nMore formal and rigorous than S3\nClasses have formal definitions for their fields and inheritance (thus more formal and rigorous than S3)\nMultiple dispatch (thus more complicated than S3)\nMultiple inheritance (thus more complicated than S3)\n\nExample\n\nAn example case is used to demonstrate the fundamentals of the S4 OOP system. In this example, the analytical flow of three data-learning models, specifically, the specification, fitting, and accessing parameters of the General Linear Model, the Generalised Linear Model, and the Neural Network Model, are implemented using the S4 OOP system.\nNote that the relationship between the General Linear Model and the Generalised Linear Model can be viewed differently, depending on specific goals (e.g. pedagogy, implementation). It can be viewed that the Generalised Linear Model is a general class of models that includes the General Linear Model as a special case where the identity function is the link, this tends to be viewed in the field of statistics. It can also be viewed that the General Linear Model is a general class which includes the Generalised Linear Model as an extension by adding the link function, this view is more in line with the concept of classes in object-oriented programming. While both views are valid, the latter view is adapted to demonstrate the inheritance of classes in the S4 OOP system.\n\n\nClasses\n\nIntroduction\n\nS4 classes have a more formal definition than S3 classes\nAn S4 class is defined by the name of the class, a set of parameters and their data types\nThe set of parameters is referred to as the “representation” and individual parameters are referred to as “slots” or “representations” (conceptualised as similar to the concept of “attributes” in S3 classes)\n\nClass creation\n\nThe setClass function creates an S4 class with its definition specified through its arguments and returns an object generator function of the class (hereinafter referred to as “generator function”).\nThe generator function provides one of two ways of creating objects of the class (more details in the objects section). More relevant here is that purely calling setClass would only return the generator function (and create the class) but not registering the returned generator function as an object in the variable environment that could be used. The output of setClass needs to be assigned to an object, ideally with its name the same as the class name for clarity, for the generator function to be used. As mentioned, the generator function is only one of two ways of creating objects of the class, hence, creating a class by simply calling setClass without assigning the output to an object is sufficient, but additionally assigning the output to an object is recommended as this eliminates any ambiguity if two classes from different packages have the same name with relative ease.\nThe setClass function has the general usage\n\nclass_name &lt;- setClass(Class = \"class_name\", representation, prototype, contains)\n\nWhere\n\nThe Class argument specifies the name of the class\nThe representation argument specifies the representation and the data types of the slots\nThe prototype argument specifies the default values of the slots, these must conform to their specified data types\nThe contains argument specifies any subclasses of the class from which slots are inherited\n\n\n\n\n\nExample\n\n\n# Create some data\nattainment_data &lt;- data.frame(\n  ks1_maths = rnorm(100, mean = 0, sd = 15),\n  ks2_maths = rnorm(100, mean = 0, sd = 15),\n  ks2_science = rnorm(100, mean = 0, sd = 15),\n  ks2_english = rnorm(100, mean = 0, sd = 15),\n  ks2_art = rnorm(100, mean = 0, sd = 15),\n  school_teaching_quality = rnorm(100, mean = 0, sd = 15),\n  idaci = abs(rnorm(100, mean = 0, sd = 15)),\n  ses = rpois(n = 100, lambda = 5),\n  home_to_school_travel_time = rpois(n = 100, lambda = 50),\n  diet_quality = rpois(n = 100, lambda = 10)\n)\n\n# Create a class \"general_linear_model\" that's defined by two slots of \"y\", an outcome as a character string/vector with no default values, and \"x\", the predictors as a character string/vector with an NA character as the default value \nsetClass(\n  Class = \"general_linear_model\",\n  representation = representation(\n    y = \"character\", # The outcome\n    x = \"character\" # The predictor(s)\n  ),\n  prototype = prototype(\n    x = NA_character_ # Setting an NA character as the default for \"x\"\n    )\n  )\n\n# Create a class \"generalised_linear_model\" defined by (slots in) its superclass \"general_linear_model\" while extending it by adding a slot \"family\" for the link function. Assign the output (the returning generator function) to an object \"generalised_linear_model\", so that this object can be used as its generator function.\ngeneralised_linear_model &lt;- setClass(\n  Class = \"generalised_linear_model\",\n  representation = representation(\n    family = \"function\" # The link function\n    ),\n  prototype = prototype(\n    family = identity  # Setting the identity function as the default link function \n    ),\n  contains = \"general_linear_model\" # Specifying that the \"generalised_linear_model\" class is a subclass/childclass/extension/special case of the superclass/parentclass \"general_linear_model\" (it contains all the slots of the \"general_linear_model\" class). This effectively inherits all class definitions of the class \"general_linear_model\" (i.e. \"x\" and \"y\"). Hence, this class has a total of three slots.\n  )\n\n\n\n# Create a class \"neural_network_model\" defined by slots of \"x\", the predictors, and \"y\", the outcomes\nneural_network_model &lt;- setClass(\n  Class = \"neural_network_model\",\n  representation = representation(\n    y = \"character\",\n    x = \"character\"\n    )\n  )\n\n# Access basic properties of the class \"generalised_linear_model\"\nshowClass(\"generalised_linear_model\")\n\n# Access whether \"generalised_linear_model\" is an extension of \"general_linear_model\"\nextends(class1 = \"generalised_linear_model\", class2 = \"general_linear_model\")\n\n# Removing the class \"general_linear_model\"\n# removeClass(\"general_linear_model\")\n# Removing a parent class does not remove its children, though, the inheritance structure would be lost and the children wouldn't be children \n\nInstances\n\nIntroduction\n\nInstances are objects (instance object) representing cases of a class that take on specific slot values\nInstances of a subclass are also instances of its superclasses, however, instances of a superclass are not instances of their subclasses. This affects methods dispatch.\n\ninstance creation\n\nS4 instances are created by the new function with its class and values of slots specified through its arguments\nThe new function has the general form\n\nnew(Class, ...)\n\nWhere\n\nThe Class argument specifies the name of the class the instance is of\n... is the set of slots of the specified class as arguments that specify values of the slots for the instance\n\n\n\nS4 instances of a class can also be created indirectly by its generator function with its values of slots specified through its arguments (applicable only if the generator function exists as a function object), calling the generator function would in turn call the new function to create the instance\nThe generator function has similar form as the new function (only difference is that it doesn’t have the Class argument because it has been specified)\n\ngenerator_function(...)\n\nWhere\n\ngenerator_function is the name of the generator function\n... is the set of slots of the specified class as arguments that specify values of the slots for the instance\n\n\n\n\nAccess and modify values of slots of instances\n\nValues of slots of instances can be assessed using two methods, either through the @ symbol (instance@slot_name) or the slot function (slot(object  = instance, name = \"slot_name\"))\nAssessed values can then be modified using the assignment operator &lt;- (i.e. instance@slot_name &lt;- value or slot(instance, \"slot_name\") &lt;- value)\n\nExample\n\n\n# Create an instance of class \"general_linear_model\" using the new function with the value of \"y\" being \"ks2\" and values of \"x\" being \"ks1_maths\" and \"school_teaching_quality\"\nmaths_general_linear_model &lt;- new(\n  Class = \"general_linear_model\",\n  y = \"ks2_maths\",\n  x = c(\"ks1_maths\", \"school_teaching_quality\")\n)\n \n# Access properties of the instance \"maths_general_linear_model\"\nstr(maths_general_linear_model)\n\n# Access whether the object \"maths_general_linear_model\" is an object of an S4 class\nisS4(maths_general_linear_model)\n\n# Create an instance of class \"generalised_linear_model\" using its generator function (as the generator function exists in the form of an object in the environment)\nmaths_generalised_linear_model &lt;- generalised_linear_model(\n  y = \"ks2_maths\",\n  x = c(\"ks1_maths\", \"school_teaching_quality\")\n)\n\n# Create a second instance of class \"generalised_linear_model\" using its generator function\nses_generalised_linear_model &lt;- generalised_linear_model(\n  y = \"ses\",\n  x = \"home_to_school_travel_time\",\n  family = function()identity\n)\n\n# Create an instance of class \"neural_network_nodel\" using its generator function\nscience_neural_network_model &lt;- neural_network_model(\n  y = \"ks2_science\",\n  x = c(\"ses\", \"idaci\", \"home_to_school_travel_time\", \"diet_quality\")\n)\n\n# Access the value of slot \"y\" in the instance \"maths_generalised_linear_model\" using the \"@\" operator\nmaths_generalised_linear_model@y\n\n# Access the value of a specific slot \"x\" in the instance \"maths_generalised_linear_model\" using the `slot` function\nslot(maths_generalised_linear_model, \"x\")\n\n# Modify the value of the slot \"family\" in the instance \"ses_generalised_linear_model\" using the \"@\" operator\nses_generalised_linear_model@family &lt;- function()poisson(link = \"log\")\n\n# Modify the value of the slot \"x\" in the instance \"maths_generalised_linear_model\" using the `slot` function\nslot(maths_generalised_linear_model, \"x\") &lt;- c(\"ks1_maths\", \"school_teaching_quality\", \"idaci\")\n\nGeneric functions (Generics), Methods, and Methods Dispatch\n\nIntroduction\n\nGenerics and methods\n\nA generic is a function that can take different input (in terms of the class of the inputs to the arguments and/or the set of arguments) and operate and/or behave in different specific ways according to the input upon being called\nThis is done by the generic having a set of associated methods, which are functions that implement for specific cases in terms of the inputs to the arguments to the generic, and having the generic dispatch to one of its methods upon being called through a process called methods dispatch, which involves matching and identifying the most appropriate method and passing the inputs to the arguments to the generic to that method\n\nInheritance\n\nSince instances of a subclass are also instances of its superclasses, methods defined for instances of a superclass are also applicable to instances of its subclasses. However, since instances of a superclass are not instances of their subclasses, methods defined for instances of a subclass are not applicable to instances of its superclasses\n\n\nCreating a generic\n\nThe setGeneric function creates or coerces an existing function as an S4 generic\nThe setGeneric function has the general form:\n\nsetGeneric(name, def)\n\nWhere\n\nname is the name of the generic\ndef is the “skeleton” of the generic or the non-generic (default) method of the generic as a function. This function should also include the standardGeneric function (specifically standardGeneric(f = \"generic_name\")) for initiating the S4 methods dispatch mechanism. (All of these are needed only when creating a generic)\n\n\n\n\nCreating a method\n\nThe setMethod function creates a method for a generic\nThe setMethod function has the general form\n\nsetMethod(f, definition)\n\nWhere\n\nf is the name of the generic\nsignature is the case of the classes of the inputs to the arguments to the generic for the method specified through the signature function\ndefinition is the method for the generic as a function\n\n\n\n\nTools\n\nAll signatures of a generic can be assessed by the showMethod function (showMethod(f = generic))\nAll generics and their signatures of a class can be assessed by the showMethods function (showMethods(classes = \"classname\")\nThe callNextMethod function is used within the input (function) to the definition argument inside the setMethod function, this is used to call the next most appropriate method (as if the current method doesn’t exist)\nThe removeMethod function removes a method from a generic (removeMethod(f = \"generic_name\", signature = signature(argument_1 = \"class_a\", argument_2 = \"class_b\",...)))\nThe removeGeneric function removes a generic (removeGeneric(f = \"generic_name\"))\n\nMethods Dispatch\n\nMethods dispatch is the process in which the most appropriate method of a generic is selected to be executed with the inputs to the generic upon being called based on R’s selection criteria/algorithm\n\n\nThe process in detail\n\n\nThe generic is called with specified inputs to its arguments\nThe classes of the input to the arguments to the generic are identified\nMethods matching and selection\nThe inputs to the generic are compared with the defined inputs to each of the methods in their signatures\nThe set of specified arguments in the generic being called is compared to the set of arguments to each of the methods\nIf none of the methods has the same set of arguments in their signatures as the arguments that’s being specified in the generic called, an error is returned to with a message informing that there are unused arguments\nIf there exists some methods with the same set of arguments in their signatures as the arguments that’s being specified in the generic called, if there is only one method, the method is selected and executed, if there are multiple methods, then those methods are selected for further matching and selection\nThe classes of the inputs to the arguments to the generic called are compared with the defined classes of the inputs to the arguments to each of the methods in their signatures\nIf the class of the input to at least one argument to the generic called is different to and is not a subclass of the class defined for the corresponding argument to all the methods, then an error is returned with a message informing that no methods exist for inputs of that class\nIf the class of the input to all the arguments to the generic called is exactly the same as or a subclass of the defined class of the inputs to corresponding arguments to some methods in their signatures, if there is only one method, then the method is selected and executed, if there are multiple methods, then those methods are selected for further matching and selection\nThe classes of the inputs to the arguments to the generic called are compared to the defined classes of the inputs to the arguments to each of the methods in their signatures in terms of their closeness in class membership/the inheritance hierarchy. Due to previous selections, classes of the inputs to the arguments to the generic called are either exactly the same or subclasses of the classes of the inputs to the corresponding arguments to the methods, hence, closeness refers to whether the classes are exactly the same or, if not, how many generations the classes in the generic are from the classes in the methods.\nA distance is calculated to represent the closeness between the set of classes in the generic called and the set of classes a method (generic-method pair)\nFor each generic-method pair, for each arguments, if the class of the input to the method is the same as that to the generic, then a distance of 0 is given, if the class of the input to the method is a parent to the class of the input to the generic, a distance is 1 is given, if the class of the input to the method is a grandparent to the class of the input to the generic, a distance of 2 is given, and so on. This is calculated for all arguments. Then the distances are summed over the arguments for that generic-method pair to give the total distance for the generic-method pair. This is done to all generic-method pairs. All generic-method pairs are compared in terms of their distances. The method with the smallest distance is selected and executed, however, if there are multiple methods with the smallest distance (i.e. ties), then they are selected for further selection\nIt is recommended not to design generics that go beyond this level of ambiguity, hence, further selections are not covered in detail, but basically, it selects based on the order of the arguments and then the order of the definition of the methods (methods defined earlier are given higher priority)\n\n\n\nExample\n\n\n# Create a generic \"model_description\" that takes one or two models and summarises/compares them\nsetGeneric(\n  name = \"model_description\",\n  def = function(model_1 = NULL, model_2 = NULL){ # The generic is defined to have two generic arguments \"model_1\" and \"model_2\" for specifying the models to be described/compared\n    standardGeneric(f = \"model_description\") # This is for initiating the S4 methods dispatch mechanism \n  },\n  valueClass = \"character\" # Defines the output to be of class character\n)\n\n# Create a generic \"fit\" that would take a model specification and data and fit the specified model to the data \nsetGeneric(\n  name = \"fit\",\n  def = function(model = NULL, data){\n    standardGeneric(f = \"fit\")\n  }\n)\n\n# Coerce the summary function (an existing function) as an S4 generic\n# The goal of this is to use this generic summary to summarise the models fitted by the fit generic by adding specific S4 methods to it later \nsetGeneric(name = \"summary\")\n\n\n\n# Create a method for the generic \"model_description\" for the case when the input to both arguments are of the class \"general_linear_model\"\nsetMethod(\n  f = \"model_description\",\n  signature = signature(model_1 = \"general_linear_model\", model_2 = \"general_linear_model\"),\n  definition = function(model_1, model_2){\n    if(model_1@y == model_2@y){\n      if(identical(unlist(model_1@x), unlist(model_2@x))){\n        paste0(\"Both models are General Linear Models and have the same outcome and predictors\")\n      }else{\n          paste0(\"Both models are General Linear Models and have the same outcome and but different predictors\")\n      }\n    }else{\n      if(identical(unlist(model_1@x), unlist(model_2@x))){\n        paste0(\"Both models are General Linear Models and but have a different outcome and same predictors\")\n      }else{\n          paste0(\"Both models are General Linear Models and have different outcome and predictors \")\n      }\n    }\n  }\n)\n\n# Create a second method for the generic \"model_description\" for the case when the input to both arguments are of the class \"generalised_linear_model\"\nsetMethod(\n  f = \"model_description\",\n  signature = signature(model_1 = \"generalised_linear_model\", model_2 = \"generalised_linear_model\"),\n  definition = function(model_1, model_2){\n    if(model_1@y == model_2@y){\n      if(identical(unlist(model_1@x), unlist(model_2@x))){\n        if(model_1@family()$family == model_2@family()$family){\n          paste0(\"Both models are Generalised Linear Models and have the same outcome, predictors, and family\")\n        }else{\n          paste0(\"Both models are Generalised Linear Models and have the same outcome and predictors but different families\")\n        }\n        \n      }else{\n        if(model_1@family()$family == model_2@family()$family){\n          paste0(\"Both models are Generalised Linear Models and have the same outcome and family but different predictors\")\n        }else{\n          paste0(\"Both models are Generalised Linear Models and have the same outcome but different predictors and families\")\n        }\n      }\n    }else{\n      if(identical(unlist(model_1@x), unlist(model_2@x))){\n        if(model_1@family()$family == model_2@family()$family){\n          paste0(\"Both models are Generalised Linear Models and have same predictors and family but a different outcome\")\n        }else{\n          paste0(\"Both models are Generalised Linear Models and have same predictors but a different outcome and families\")\n        }\n        paste0(\"Both models are Generalised Linear Models and have same predictors but a different outcome \")\n      }else{\n        if(model_1@family()$family == model_2@family()$family){\n          paste0(\"Both models are Generalised Linear Models and the same family but different outcome and predictors\")\n        }else{\n          paste0(\"Both models are Generalised Linear Models but have different outcome, predictors and families\")\n        }\n      }\n    }\n  }\n)\n\n\n\n# Access all signatures of the generic \"model_description\"\nshowMethods(f = model_description)\n\n# Access all generics and their signatures of objects of the class \"general_linear_model\"\nshowMethods(class = \"general_linear_model\")\n\n\n# Create a method for the fit generic for the case when the input to the model argument is of the class \"general_linear_model\"\n# Define the output of this method to be of an S4 class \"general_linear_model_fit\". To do that, the class \"general_linear_model_fit\" and its generator function need to be created first before defining the method as the generator function would be used within the method to define the class of the output of the method \ngeneral_linear_model_fit &lt;- setClass(\"general_linear_model_fit\", representation = representation(call = \"character\", coefficients = \"ANY\"))\nsetMethod(\n  f = \"fit\",\n  signature = signature(model = \"general_linear_model\"),\n  definition = function(model, data){\n    formula &lt;- paste0(model@y, \" ~ \" ,paste0(unlist(model@x), collapse = \" + \"))\n    general_linear_model_fit_object &lt;- lm(formula = formula, data = data)\n    general_linear_model_fit_call &lt;- paste0(as.character(general_linear_model_fit_object$call[1]), \"(\", as.character(general_linear_model_fit_object$call[2]), \", \",as.character(general_linear_model_fit_object$call[3]), \")\")\n    return(general_linear_model_fit(call = general_linear_model_fit_call, coefficients = general_linear_model_fit_object$coefficients))\n  }\n)\n\n# Create a second method for the fit generic for the case when the input to the model argument is of the class \"generalised_linear_model\"\n# Define the output of this method to be of an S4 class \"generalised_linear_model_fit\". Similarly, this class and its generator function are created first before defining the method. In addition, \"generalised_linear_model_fit\" is defined to be a children of \"general_linear_model_fit\", this is used to demonstrate that methods defined for instance objects of a class would also be applicable to instance objects of its subclass (but not the other way round).\ngeneralised_linear_model_fit &lt;- setClass(\"generalised_linear_model_fit\", contains = \"general_linear_model_fit\")\nsetMethod(\n  f = \"fit\",\n  signature = signature(model = \"generalised_linear_model\"),\n  definition = function(model, data){\n    formula &lt;- paste0(model@y, \" ~ \" ,paste0(unlist(model@x), collapse = \" + \"))\n      \n    generalised_linear_model_fit_object &lt;- glm(formula = formula, data = data, family = model@family()$family)\n    generalised_linear_model_fit_call &lt;- paste0(as.character(generalised_linear_model_fit_object$call[1]), \"(\", as.character(generalised_linear_model_fit_object$call[2]), \", \",as.character(generalised_linear_model_fit_object$call[3]), \", \",as.character(generalised_linear_model_fit_object$call[4]), \")\")\n    return(generalised_linear_model_fit(call = generalised_linear_model_fit_call, coefficients = generalised_linear_model_fit_object$coefficients))\n  }\n)\n\n\n# Create a third method for the fit generic for the case when the input to the model argument is of the class \"neural_network_model\"\n# The class of the output of this method is defined to be \"nn\" by the neuralnet::neuralnet function\nsetMethod(\n  f = \"fit\",\n  signature = signature(model = \"neural_network_model\"),\n  definition = function(model, data){\n    formula &lt;- paste0(model@y, \" ~ \" ,paste0(unlist(model@x), collapse = \" + \"))\n      \n    neural_network_model_fit_object &lt;- neuralnet::neuralnet(formula = formula, data = data, linear.output = F)\n    return(neural_network_model_fit_object)\n  }\n)\n\n\n# Create a same method for the summary generic for the case when the input to the object argument is either an instance of the class \"general_linear_model_fit\" or \"generalised_linear_model_fit\"\n# Since the class \"general_linear_model_fit\" is a superclass of its subclass \"generalised_linear_model_fit\", as defined in the inheritance structure when creating the class \"generalised_linear_model_fit\", any methods defined for instances of the class \"general_linear_model_fit\" would also be applicable to instances of the class \"generalised_linear_model_fit\".\n# This means that to create a method for objects of both the parent and child classes \"general_linear_model_fit\" or \"generalised_linear_model_fit\", the method only needs to be defined for the parent class \"general_linear_model_fit\"\nsetMethod(\n  f = \"summary\",\n  signature = signature(object = \"general_linear_model_fit\"),\n  definition = function(object, show_beta = F){\n    print(object@call)\n    if(show_beta){\n    object@coefficients}\n    \n  }\n)\n\n# Create a second method for the summary generic for the case when the input to the object argument is an instance of the class \"neural_network_model_fit\" in a way that the arguments to the summary generic would change accordingly, specifically, the \"show_beta\" argument would be removed and a new argument would be added, further, the \"plot_model\" argument can take inputs of different classes causing the summary function to operate differently by nesting another generic, specifically called \"summary_2\" in the method. Accordingly, the \"summary\" and \"summary_2\" generics may be referred to as the main/external and internal generics. This is to show how a generic can have different sets of arguments depending on the class of the inputs to one or more generic arguments and those new arguments can take inputs of different classes and operate differently according to them. This complex scenario is rare though.\n\n# Create the internal generic \"summary_2\" that would be nested within the methods of the main generic \"summary\" later \nsetGeneric(\n  \"summary_2\", \n  def = function(object, plot_model){\n    standardGeneric(f = \"summary_2\")\n    }\n  )\n\n# Create a method for the internal generic \"summary_2\" for the case when the input to the argument \"plot_model\" is of the class \"logical\" \nsetMethod(\n  f = \"summary_2\", \n  signature = signature(plot_model = \"logical\"),\n  definition = function(object, plot_model){\n            print(\"Input of the plot_model argument is logical\")\n            #print(object$call)\n            if(plot_model){plot(object)}\n          })\n\n# Create a second method for the internal generic \"summary_2\" for the case when the input to the argument \"plot_model\" is of the class \"numeric\"\nsetMethod(\n  f = \"summary_2\", \n  signature = signature(plot_model = \"numeric\"),\n  definition = function(object, plot_model){\n            print(\"Input of the plot_model argument is an numeric\")\n            print(object$call)\n            if(plot_model == 1){plot(object)}\n    }\n  )\n# Create a method for the main generic \"summary\" for the case when input to the \"object\" argument is of the class \"nn\" (the neural network model fit)\nsetMethod(\n  f = \"summary\",\n  signature = signature(object = \"nn\"),\n  definition = function(object, plot_model){summary_2(object = object, plot_model = plot_model)}\n)\n\n\n# Show how it all works in practice\n# Fit the models to the data using the fit generic\n# The fit generic can take various model specifications of various types of model and fit to the same data accordingly \n# Fitting a General Linear Model\nmaths_general_linear_model_fit &lt;- fit(model = maths_general_linear_model, data = attainment_data)\n# Fitting a Generalised Linear Model \nses_generalised_linear_model_fit &lt;- fit(model = ses_generalised_linear_model, data = attainment_data)\n# Fitting a Neural Network Model\nscience_neural_network_model_fit &lt;- fit(model = science_neural_network_model, data = attainment_data)\n\n# Access the model properties using the summary generic \n# The summary generic can take inputs of different classes and change its arguments and operations/output\nsummary(maths_general_linear_model_fit, show_beta = T)\nsummary(ses_generalised_linear_model_fit, show_beta = F)\nsummary(science_neural_network_model_fit, plot_model = T)\nsummary(science_neural_network_model_fit, plot_model = 1)"
  }
]